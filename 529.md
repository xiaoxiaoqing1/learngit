# 529 #
## redis支持的数据类型 ##
1. 字符串 string：一个键对应一个值，一个简直最大存储512mb
2. 哈希  hash：是一个键值对集合，是一个string类型的field和value的映射表，蛇和用于存储对象
3. 列表  list：是redis的简单的字符串列表，它按插入顺序排序
4. 集合  sets：是字符串类型的无需集合，也不可重复
5. 有序集合  sorted sets：是string类型的有序集合，也不可重复，有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序，如果多个元素有相同的分数，则以字典序进行升序排序，sorted set因此非常适合实现排名。


## redis恢复数据 ##
如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可

## 创建备份文件 ##
如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可

## redis发布订阅 ##
- pub发送者，发送消息
- sub订阅者，订阅消息

## Redis事务 ##
可以一次执行多个命令，并且带有以下两个重要的保证：
- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中

一个事务从开始到执行会经历以下三个阶段：
- 开始事务
- 命令入队
- 执行事务

## reids持久化 ##
两种方式

1. 快照（快照）
	- 将存储在内存的数据以快照的方式写入二进制文件中，如默认dump.rdb中
	- 保存：900 1   900秒内如果一个key被修改，则启动快照保存
	- 保存300 10    300秒内如果超过10个key被修改，则启动快照保存
	- 保存60 10000   60秒内如果10000个重点被修改，则启动快照保存

2. 仅附加文件（AOF）
 - 使用aof持久时，服务会将每个收到的命令通过写函数追加到文件中(appendonly.aof）
	- aof持久化存储方式参数说明  appendonly yes
	- 开启aof持久化存储方式    appendfsync  always
	- 收到写命令后就立即写入磁盘，效率最差，效果最好  appendfsync everysec
	- 每秒写入磁盘一次，效率与效果居中appendfsyn  no

## redis单线程问题 ##
所谓的单线程指的是网络请求模块使用了一个线程（所以不需要考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。

redis采用多路复用机制：即多个网络socket复用一个io线程，实际是单个线程通过记录跟踪每一个sock（i/o流）的状态来同时管理多个i/o流。

## 行级锁 ##
开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。
## 表级锁 ##
开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突的概率最高，并发度最低。
## 页面锁 ##
开锁和加索时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。
## MyISAM表锁 ##
有两种模式：

1. 表共享读锁
2. 表独占写锁	（对myisam表的写操作，会阻塞其他用户对同一表的读和写操作）


myisam存储引擎的写锁阻塞读例子：

	当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，知道锁被释放为止。

myisam存储引擎的读锁阻塞写例子：
	一个session使用lock table命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。



	给指定的表加读锁：lock table 表名 read;
	给指定的表解除锁:unlock tables

## 如何加表锁 ##
myisam在执行查询语句（select）前，会自动给设计的所有表加读锁，在执行更新操作前，会自动给设计的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用lock table命令给myisam表显示加锁。在示例中，显示加索基本上都是为了演示而已，不是必须这样。

给myisam表显示加索，一般是为了在一定程度模拟事务操作，实现对某一事件点多个表的一致性读取。



