# 517日 # 

# char与varchar类型区别 #
char数据类型与varchar数据类型不同，其采用的是固定长度的存储方式。简单来说，就是系统总为其分配最大的存储空间。


# 关于redis #
## 缓存和数据库间数据一致的问题 ##

分布式环境下，非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。

## 缓存击穿问题 ##
缓存急促韩表视恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库异常。

1. 使用互斥锁排队：根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其他线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、lock）就够了。（锁机制使得逻辑的复杂度增加，吞吐量也降低了，有点治标不治本）。
2. 接口限流与熔断，降级：重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用的时候，进行熔断，失败快速返回机制。

## 缓存雪崩问题 ##
缓存在同一时间内大量建过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常

解决：
1. 也是像解决缓存穿透一样加排队所，实现同上；
2. 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设置超时时间，先从A读缓存，A没有读B，并且跟新A缓存和B缓存；
3. 设置缓存超时时间的时候加上一个随时的时间长度，比如这个缓存key的超时时间是固定的五分钟加上随机的两分钟，这样可以一定程度上避免雪崩问题；


## 缓存并发问题 ##
这里的并发指的是多个redis的client同时set key引发的并发问题。其实
redis自身就是单线程操作，多个client并发操作，按照先到执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行，具体的代码就不上了，当然加索也是可以的，但一般不用redis中的事务。




# 单点登录 #

单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任

https://blog.csdn.net/youcijibi/article/details/78351627

