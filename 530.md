# 530 #
## mysql的隔离级别和所的关系 ##
1. 事务的四个基本特征
- Atomic（原子性）：事务中包括的操作被看作一个逻辑单元。这个逻辑单元中的操作要么所有成功。要么所有失败。
- Consistency(一致性)：仅仅有合法的数据能够被写入数据库，否则事务应该将其回滚到最初状态。
- lsolation（隔离性）：事务同意多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同一时候。并行事务的改动必须与其他并行事务的改动相互独立
- Durability（持久性）：事务结束后。事务处理得结果必须可以得到固化。
 
 
 
## 数据库隔离级别 ##
数据库食物的隔离级别有4个。由低到高依次为Read uncommitted 、Read committed、Repeatable read、Serializable。这四个级别能够逐个解决脏读、不可反复读、幻读这几类问题。

					
	Read uncommitted(读未提交)     |  脏读  ｜不可重复读  ｜ 幻读
	Read committed（读提交）       |		 |不可重复读  | 幻读
	Repeatable read（反复读）      |		 | 			 |幻读
	Serializable（序列化）		  |		 |			 |			
- read uncommitted读未提交：是限制性最弱的隔离级别。由于该级别忽略其他事务放置的锁。使用read uncommitted级别运行的事务，能够读取尚未由其他事物提交的改动后的数据值，这些事务称为“脏”读。比如，事务1改动一行，事务2就读取了一行没有提交的数据。这种数据我们觉得是不存在的。
- Read commiitted读提交：该级别通过指定语句不能读取其他事物以改动可是尚未提交的数据值。禁止运行脏读。在当前事务中的各个语句运行之间，其他事务仍能够驱动、插入或删除数据。从而产生无法反复的读操作，或“影子”数据。比方，事务1读取了一行。事务2改动或者删除这一行而且提交。假设事务1想再一次读取这一行，它将获得改动后的数据或者发现这一样已经被删除。因此事务的第二次读取结果与第一次读取结果不同，因此也叫不可反复读。
- Repeatable read反复读:repeatable read是比read committed限制性更强的隔离级别。该级别包含read committed，而且另外指定了在当前事务提交之前。其他不论什么事务都不能够改动或删除当前事务已读取的数据。并发性低于read committed。由于一度数据的共享锁在整个事务旗舰持有，而不是在每一个结束时释放。	

		这个隔离级别仅仅是说，不可以改动和删除，可是并没有强制不能插入新的满足条件查询的数据行。（repeatable read隔离级别保证了在同样的查询条件下，同一个事务中的两个查询。第二次读取的内容肯定包换第一次读到的内容。注：mysql的默认隔离级别就是repeatable read）

- serializable序列化：是限制性最强的隔离级别，由于该级别锁定整个范围的键。并且一直持有锁，知道事务完毕。该级别包含repeatable read。并添加了在事务完毕之前，其他事务不能向事务一度去的范围插入新行的限制。比方，事务1读取了一系列满足搜索条件的行。事务2在运行SQL statement产生一行或者多行满足事务1搜索条件的行时会冲突。则事务2回滚。这时事务1再次读取了一系列满足同样搜索条件的行。第二次读取的结果和第一次读取的结果同样。



## 反复读和幻读 ##
- 反复读：是为了保证一个事务中，相同查询条件下读取的数据值不发生改变，可是不能保证下次相同查询。结果记录数不会添加。
- 幻读就是为了解决问题而存在的，他将这个查询范围都加索了。所以就不能再往这个范围内插入数据。这就是serializable（序列化）隔离级别做的事情。


## 死锁的产生原因 ##
所谓死锁（deadlock）：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，他们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在相互等待的进程称为死锁进程。表级锁不会产生死锁，所以解决死锁主要还是针对于最常用的innodb。

死锁的关键在于：两个（或以上的）session加锁的顺序不一致。

解决死锁问题的关键：让不同的session加索有次序。

innodb上删除一条记录，并不是真正意义上的物理删除，而是将记录标识为删除状态。（注：这些标识为删除状态的记录，后续会由后台的purge操作进行回收，乌里删除。但是，删除状态的记录会在索引中存放一段时间。）

## 死锁预防策略 ##
innodb引擎内部（或者说是所有的数据库内部），有多种锁类型：事务锁（行锁，表锁），mutex（保护内部的共享变量操作），rwlock又称为latch，保护内部的页面读取与修改