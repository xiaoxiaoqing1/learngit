# 530 #
## mysql的隔离级别和所的关系 ##
1. 事务的四个基本特征
- Atomic（原子性）：事务中包括的操作被看作一个逻辑单元。这个逻辑单元中的操作要么所有成功。要么所有失败。
- Consistency(一致性)：仅仅有合法的数据能够被写入数据库，否则事务应该将其回滚到最初状态。
- lsolation（隔离性）：事务同意多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同一时候。并行事务的改动必须与其他并行事务的改动相互独立
- Durability（持久性）：事务结束后。事务处理得结果必须可以得到固化。
 
 
 
## 数据库隔离级别 ##
数据库食物的隔离级别有4个。由低到高依次为Read uncommitted 、Read committed、Repeatable read、Serializable。这四个级别能够逐个解决脏读、不可反复读、幻读这几类问题。

					
	Read uncommitted    |  脏读  ｜不可重复读  ｜ 幻读
	Read committed      |		 |不可重复读  | 幻读
	Repeatable read     |		 | 			 |幻读
	Serializable		|		 |			 |			
- read uncommitted读未提交：是限制性最弱的隔离级别。由于该级别忽略其他事务放置的锁。使用read uncommitted级别运行的事务，能够读取尚未由其他事物提交的改动后的数据值，这些事务称为“脏”读。比如，事务1改动一行，事务2就读取了一行没有提交的数据。这种数据我们觉得是不存在的。
- Read commiitted读提交：该级别通过指定语句不能读取其他事物以改动可是尚未提交的数据值。禁止运行脏读。在当前事务中的各个语句运行之间，其他事务仍能够驱动、插入或删除数据。从而产生无法反复的读操作，或“影子”数据。比方，事务1读取了一行。事务2改动或者删除这一行而且提交。假设事务1想再一次读取这一行，它将获得改动后的数据或者发现这一样已经被删除。因此事务的第二次读取结果与第一次读取结果不同，因此也叫不可反复读。
- Repeatable read反复读:repeatable read是比read committed限制性更强的隔离级别。该级别包含read committed，而且另外指定了在当前事务提交之前。其他不论什么事务都不能够改动或删除当前事务已读取的数据。并发性低于read committed。由于一度数据的共享锁在整个事务旗舰持有，而不是在每一个结束时释放。	

		这个隔离级别仅仅是说，不可以改动和删除，可是并没有强制不能插入新的满足条件查询的数据行。（repeatable read隔离级别保证了在同样的查询条件下，同一个）